window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "gadcp", "modulename": "gadcp", "type": "module", "doc": "<p>Package for dealing with RDI Teledyne ADCP data in various ways. The code\ninterfaces the UH package <code>pycurrents</code> and its <code>Multiread</code> for efficient\nreading of raw ADCP data. The code is based on the <a href=\"https://currents.soest.hawaii.edu/hgstage/pycurrents\">pycurrents</a> package, installation instructions can be found <a href=\"https://currents.soest.hawaii.edu/ocn_data_analysis/installation.html\">here</a>.</p>\n\n<p><code>gadcp.io</code> provides convenience functions for reading raw data either into\nan <code>xarray.Dataset</code> or into the output structure format provided by the UH\nsoftware package.</p>\n\n<p><code>gadcp.adcp</code> is a collection of functions that are useful to quickly\nanalyze raw ADCP data.</p>\n\n<p><code>gadcp.madcp</code> contains functions for processing moored ADCP data. Many thanks to Eric Fiering for sharing his code on moored ADCP data processing <a href=\"https://currents.soest.hawaii.edu/hgstage/pycurrents/file/tip/pycurrents/adcp/mcm_avg.py\">mcm_avp.py</a> that much of this is based on.</p>\n\n<hr />\n\n<p>TODO: Move <code>gadcp.adcp.LADCPYoYoSplit</code> to its own ladcp submodule.</p>\n"}, {"fullname": "gadcp.adcp", "modulename": "gadcp.adcp", "type": "module", "doc": "<p>Module gadcp.adcp with adcp functions</p>\n"}, {"fullname": "gadcp.adcp.plot_raw_adcp", "modulename": "gadcp.adcp", "qualname": "plot_raw_adcp", "type": "function", "doc": "<p>Plot raw RDI adcp dataset.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>adcp</strong> (xarray.Dataset):\nRaw RDI ADCP data read using gvpy.io.read_raw_rdi()</li>\n<li><strong>figsize</strong> (tuple):\nProvide figure size (default (17, 20))</li>\n</ul>\n", "signature": "(adcp, figsize=(17, 20))", "funcdef": "def"}, {"fullname": "gadcp.adcp.plot_raw_adcp_auxillary", "modulename": "gadcp.adcp", "qualname": "plot_raw_adcp_auxillary", "type": "function", "doc": "<p>Plot raw RDI adcp dataset (auxillary data only).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>adcp</strong> (xarray.Dataset):\nRaw RDI ADCP data read using gvpy.io.read_raw_rdi()</li>\n<li><strong>figsize</strong> (tuple):\nProvide figure size (default (17, 20))</li>\n</ul>\n", "signature": "(adcp, figsize=(12, 5))", "funcdef": "def"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit", "type": "class", "doc": "<p>Split raw ADCP files from yoyo or towyo time series.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>downlooker</strong> (str):\nPath to raw downlooker data</li>\n<li><strong>uplooker</strong> (str):\nPath to raw uplooker data</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>var</strong> (dtype):\ndescription</li>\n</ul>\n"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit.__init__", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, downlooker, uplooker)", "funcdef": "def"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit.ts_plot", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit.ts_plot", "type": "function", "doc": "<p></p>\n", "signature": "(self, adcp, var, ax=None)", "funcdef": "def"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit.plot_pressure", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit.plot_pressure", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit.save_temp_files", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit.save_temp_files", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit.find_split_points", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit.find_split_points", "type": "function", "doc": "<p></p>\n", "signature": "(self, dx=500, mindz=300)", "funcdef": "def"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit.plot_indices", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit.plot_indices", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gadcp.adcp.LADCPYoYoSplit.split_files", "modulename": "gadcp.adcp", "qualname": "LADCPYoYoSplit.split_files", "type": "function", "doc": "<p></p>\n", "signature": "(self, experiment, cruise, cast, outdir)", "funcdef": "def"}, {"fullname": "gadcp.io", "modulename": "gadcp.io", "type": "module", "doc": "<p>Module gadcp.io with in/out functions. Mostly provides wrapper functions to UHs <code>Multiread</code>.</p>\n"}, {"fullname": "gadcp.io.read_raw_rdi", "modulename": "gadcp.io", "qualname": "read_raw_rdi", "type": "function", "doc": "<p>Read raw RDI ADCP data file and return as xarray Dataset.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file</strong> (str or Path):\nPath to raw data file.</li>\n<li><strong>auxillary_only</strong> (bool):\nSet to True to ignore 2d fields. (default False)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>rdi</strong> (xarray.Dataset):\nRaw ADCP data in xarray Dataset format.</li>\n</ul>\n", "signature": "(file, auxillary_only=False)", "funcdef": "def"}, {"fullname": "gadcp.io.read_raw_rdi_uh", "modulename": "gadcp.io", "qualname": "read_raw_rdi_uh", "type": "function", "doc": "<p>Wrapper for UH's pycurrents.adcp.rdiraw.Multiread</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>file</strong> (str or Path):\nPath to raw data file.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>radcp</strong> (dict (Bunch)):\nUH data structure with raw RDI data</li>\n</ul>\n", "signature": "(file, auxillary_only=False)", "funcdef": "def"}, {"fullname": "gadcp.madcp", "modulename": "gadcp.madcp", "type": "module", "doc": "<p>Module gadcp.madcp with functions for moored ADCPs.</p>\n\n<h3 id=\"notes\">Notes</h3>\n\n<p>Some general notes and to do items for this module.</p>\n\n<h4 id=\"depth-gridding\">Depth Gridding</h4>\n\n<p>The depth vector for the ADCP raw data (in instrument coordinates) is\ncalculated in <code>pycurrents.rdiraw.FileBBWHOS</code> as <br>\n<code>dep = np.arange(NCells) * CellSize + Bin1Dist</code>\nThe depth vector thus points to the center of each bin.</p>\n\n<p>From the RDI manual <em>WorkHorse Monitor, Sentinel, Mariner, Quartermaster, and\nLong Ranger ADCPs Commands and Output Data Format</em>:</p>\n\n<blockquote>\n  <p>This [Bin1Dist] field contains the distance to the middle of the first depth\n  cell (bin). This distance is a function of depth cell length (WS), the\n  profiling mode (WM), the blank after transmit distance (WF), and speed of\n  sound.</p>\n</blockquote>\n\n<h4 id=\"to-do\">To Do</h4>\n\n<ul>\n<li>Default depth grid: if minimum/maximum pressure changes much from median, we need to do this differently</li>\n<li>Pressure time series: If calculating averages over regular time intervals, we need to low pass filter the pressure time series prior to creating the depth vectors.</li>\n<li>Pressure time series: Allow for input of external pressure time series.</li>\n</ul>\n"}, {"fullname": "gadcp.madcp.ProcessADCP", "modulename": "gadcp.madcp", "qualname": "ProcessADCP", "type": "class", "doc": "<p>Moored ADCP Processing.</p>\n\n<p>An instance of ProcessADCP is initialized by providing raw data and\nprocessing parameters. Once initialized, the instance method\n<code>average_ensembles</code> can be used to average over just a few or\nall pings.</p>\n\n<p>Magnetic declination is automatically calculated via a call to the command\nline tool\n<a href=\"https://currents.soest.hawaii.edu/hgstage/geomag/file/tip\">magdec</a> that\nmust be installed. Once calculated, the magnetic declination is stored in\n<code>magdec</code> and automatically applied to the data.</p>\n\n<p>Prior to time averaging, data are edited based on correlation and error\nvelocity thresholds. The variable <code>pg</code> is calculated based on the number of\nexcluded pings, i.e. it is the numbur of good pings divided by the number\nof total pings within one depth bin and one time bin. It may be used to\nfurther filter the data.</p>\n\n<p>A pdf document on ADCP data collection and processing principles can be\ndownloaded from RDI\n<a href=\"https://www.comm-tec.com/Docs/Manuali/RDI/BBPRIME.pdf\">here</a>.</p>\n\n<p>Time-averaged data are grouped together in an <code>xarray.Dataset</code> in the\ninstance attribute <code>ds</code> for easy access and convenient output to netcdf\nformat.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raw_data</strong> (str or list or Path):\nLocation(s) of raw data.</li>\n<li><strong>meta_data</strong> (dict):\nDictionary with meta data. At a minimum entries for <code>lon</code> and <code>lat</code> are\nneeded. If <code>mooring</code> and <code>sn</code> provide mooring name and serial number\nthen these will be used to name the log file produced during\nprocessing.</li>\n<li><strong>driftparams</strong> (dict, optional):\nTime drift parameters. See notes below.</li>\n<li><strong>tgridparams</strong> (dict, optional):\nTime gridding parameters. See notes below.</li>\n<li><strong>dgridparams</strong> (dict, optional):\nDepth gridding parameters. See notes below.</li>\n<li><strong>editparams</strong> (dict, optional):\nEditing parameters. See notes below.</li>\n<li><strong>ibad</strong> (bool, optional):\nMark beam with bad data (zero based).</li>\n<li><strong>logdir</strong> (str, optional):\nLog file directory. Defaults to <code>log/</code>.</li>\n</ul>\n\n<h6 id=\"attributes\">Attributes</h6>\n\n<ul>\n<li><strong>files</strong> (list):\nList pointing to raw data file(s).</li>\n<li><strong>dday_start</strong> (float):\nStart time of ADCP time series, determined either through <code>t0</code> in\n<code>tgridparams</code> or the start of the time series once at depth.</li>\n<li><strong>dday_end</strong> (float):\nEnd time of ADCP time series, determined either through <code>t1</code> in\n<code>tgridparams</code> or the end of the time series at depth.</li>\n<li><strong>start_ddays</strong> (list):\nStart times of averaging intervals</li>\n<li><strong>dday_mid</strong> (float):\nTime stamp for ping average as determined in <code>make_start_ddays</code>.</li>\n<li><strong>dt</strong> (float):\nTime that is inclusive of one average. For regular averaging, this is\n<code>dt_hours</code> in <code>tgridparams</code> converted to Julian days. For\nburst-averagint, this is a time interval that is inclusive of all pings\nin one bursts (but goes slightly beyond that into the time between\nbursts).</li>\n<li><strong>time_drift_rate</strong> (float):\nClock drift calculated from <code>driftparams</code>.</li>\n<li><strong>orientation</strong> (str):\nInstrument orientation <code>up</code> or <code>down</code>.</li>\n<li><strong>magdec</strong> (float):\nMagnetic declination.</li>\n<li><strong>m</strong> (pycurrents.adcp.rdiraw.Multiread):\nMultiread instance.</li>\n<li><strong>tsdat</strong> (Bunch):\nAuxiliary data.</li>\n<li><strong>raw</strong> (xarray.Dataset):\nRaw ADCP data.</li>\n<li><strong>ds</strong> (xarray.Dataset):\nTime-averaged dataset added by running <code>average_ensembles</code>.</li>\n</ul>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>Various parameters are passed to the instance through dictionaries. Their\nspecifics are described below. Gridding and editing parameters can be\nupdated after creating the ProcessADCP instance via <code>parse_dgridparams</code>,\n<code>parse_tgridparams</code>, and  <code>parse_editparams</code>.</p>\n\n<p><strong>Time drift parameters</strong>\nProvide clock drift parameters via <code>driftparams</code>. Accepted entries are</p>\n\n<ul>\n<li><code>end_adcp</code> : Time of ADCP at data download</li>\n<li><code>end_pc</code> : UTC time at data download</li>\n</ul>\n\n<p>The difference between <code>end_adcp</code> and <code>end_pc</code> is used to linearly correct\nfor instrument clock drift.</p>\n\n<p><strong>Time gridding parameters</strong>\nProvide time gridding parameters via <code>tgridparams</code>. Accepted entries are</p>\n\n<ul>\n<li><code>dt_hours</code> : Time grid interval. Defaults to 0.5h.</li>\n<li><code>t0</code> : Start time for gridding. Determined from data if not provided.</li>\n<li><code>t1</code> : End time for gridding. Determined from data if not provided.</li>\n<li>burst_average :</li>\n</ul>\n\n<p><strong>Depth gridding parameters</strong>\nProvide depth gridding parameters via <code>dgridparams</code>. Accepted entries are</p>\n\n<ul>\n<li><code>dtop</code> : Shallow depth in m.</li>\n<li><code>dbot</code> : Deep depth in m.</li>\n<li><code>dinterval</code> : Vertical grid size in m. Defaults to 5m.</li>\n</ul>\n\n<p>Values for <code>dbot</code> and <code>dtop</code> are generated if not provided.</p>\n\n<p><strong>Editing parameters</strong>\nProvide editing parameters via <code>editparams</code>.</p>\n\n<ul>\n<li><code>max_e</code>=0.2,  # absolute max e</li>\n<li><code>max_e_deviation</code>=2,  # max in terms of sigma</li>\n<li><code>min_correlation</code>=64,  # 64 is RDI default</li>\n<li><code>maskbins</code> : Array with booleans indexing into the ADCP bins. Use the\nconvenience method <code>generate_binmask</code>.</li>\n</ul>\n"}, {"fullname": "gadcp.madcp.ProcessADCP.__init__", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    raw_data,\n    meta_data,\n    driftparams=None,\n    tgridparams=None,\n    dgridparams=None,\n    editparams=None,\n    ibad=None,\n    logdir='log',\n    verbose=False,\n    plot=False,\n    pressure_scale_factor=1\n)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.parse_file_locations", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.parse_file_locations", "type": "function", "doc": "<p>Parse input for raw data files.</p>\n\n<p>Input can either be a single file name as a str, a single file as a\nPath instance, a list of either of these, or a Path instance pointing to a\ndirectory with raw ADCP files. In the latter case, files that are\nsmaller than a threshold will not be included in the processing.</p>\n\n<p>Outputs to attribute <code>files</code>. The output can be fed to Multiread instances.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>raw_data</strong> (str or list or Path):\nLocation(s) of raw data.</li>\n<li><strong>min_file_size</strong> (int):\nMinimum size for file to be included. Defaults to 1e4 which\ncorresponds to about 10kB and is a good value for excluding small\nfiles without any actual data.</li>\n</ul>\n", "signature": "(self, raw_data, min_file_size=10000.0)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.default_dgridparams", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.default_dgridparams", "type": "variable", "doc": "<p>Default depth gridding parameters.</p>\n\n<p>This is based on median depth of the ADCP and the bin sizes.</p>\n"}, {"fullname": "gadcp.madcp.ProcessADCP.parse_dgridparams", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.parse_dgridparams", "type": "function", "doc": "<p>Parse depth gridding parameters.</p>\n\n<p>See top level class notes for more info.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>dgridparams</strong> (dict):</li>\n</ul>\n", "signature": "(self, dgridparams)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.parse_tgridparams", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.parse_tgridparams", "type": "function", "doc": "<p>Parse time gridding parameters.</p>\n\n<p>See top level class notes for more info.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>tgridparams</strong> (dict):</li>\n</ul>\n", "signature": "(self, tgridparams)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.parse_editparams", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.parse_editparams", "type": "function", "doc": "<p>Parse editing parameters.</p>\n\n<p>See top level class notes for more info.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>editparams</strong> (dict):</li>\n</ul>\n", "signature": "(self, editparams)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.parse_driftparams", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.parse_driftparams", "type": "function", "doc": "<p>Parse time drift parameters.</p>\n\n<p>See top level class notes for more info.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>driftparams</strong> (dict):</li>\n</ul>\n", "signature": "(self, driftparams)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.make_start_ddays", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.make_start_ddays", "type": "function", "doc": "<p>Generate time stamps for ping averaging.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>If turning on burst averaging, other input values will be ignored and\nthe averaging interval will be determined from the burst sampling\nscheme apparent in the ping pattern.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.read_ensemble", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.read_ensemble", "type": "function", "doc": "<p>Read ensembles (several individual pings grouped together).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>iens</strong> (int):\nIndex into ensemble start times (they are generated in\n<code>make_start_ddays</code>).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>dat</strong> (pycurrents.adcp.rdiraw.Bunch):\nDictionary with data.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If <code>iens</code> is too large to index into <code>start_ddays</code>.</li>\n</ul>\n", "signature": "(self, iens)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.magdec", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.magdec", "type": "variable", "doc": "<p>Magnetic declination.</p>\n\n<p>Calculated using\n<a href=\"https://currents.soest.hawaii.edu/hgstage/geomag/file/tip\">magdec</a>\n(must be installed) based on <code>lon</code> and <code>lat</code>.</p>\n"}, {"fullname": "gadcp.madcp.ProcessADCP.raw", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.raw", "type": "variable", "doc": "<p>Raw ADCP data.</p>\n"}, {"fullname": "gadcp.madcp.ProcessADCP.average_ensembles", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.average_ensembles", "type": "function", "doc": "<p>Time-averaging.</p>\n\n<p>Adds results as dictionary under <code>ave</code> and as <code>xarray.Dataset</code> under <code>ds</code>.</p>\n\n<p>Writes processing parameters to the log file.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>start</strong> (int):\nRange start for averaging. Index into start times of averaging\nintervals.</li>\n<li><strong>stop</strong> (int):\nRange start for averaging. Index into start times of averaging\nintervals.</li>\n</ul>\n", "signature": "(self, start=None, stop=None)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.plot_echo_stats", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.plot_echo_stats", "type": "function", "doc": "<p>Plot beam statistics (correlation and amplitude) from raw ADCP data.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.plot_pressure", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.plot_pressure", "type": "function", "doc": "<p>Plot pressure time series and mark time at depth.</p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "gadcp.madcp.ProcessADCP.generate_binmask", "modulename": "gadcp.madcp", "qualname": "ProcessADCP.generate_binmask", "type": "function", "doc": "<p></p>\n", "signature": "(self, indices)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();